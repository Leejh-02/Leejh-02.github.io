---
layout: post
title:  "리눅스 기초 명령어"
date:   2025-05-21
#category: 
image: assets/img/blog/blog9.jpg
author: 이주환
tags: rock
---


리눅스 운영체제를 다루는 데 있어 **명령어 라인 인터페이스(CLI)**의 숙달은 필수적인 역량입니다. 텍스트 기반의 명령어는 그래픽 사용자 인터페이스(GUI)로는 할 수 없는 섬세하고 강력한 시스템 제어를 가능하게 합니다. 이 가이드는 리눅스 시스템 관리, 파일 조작, 사용자 관리, 프로세스 제어 등 다양한 작업을 위한 핵심 명령어를 소개합니다.

1. 시스템 정보 및 관리 명령어
리눅스 시스템의 전반적인 상태를 파악하고 기본적인 시스템 설정을 관리하는 데 사용되는 명령어들입니다.

uname -a

설명: 현재 시스템의 모든 커널 정보를 출력합니다. 커널 버전, 운영체제, 하드웨어 아키텍처 등을 포함하여 시스템의 근본적인 환경을 파악할 수 있습니다.
사용 예시: uname -a
df -h

설명: 파일 시스템의 디스크 공간 사용량을 사람이 읽기 쉬운(human-readable) 형식으로 보여줍니다. 각 마운트된 파티션의 총 용량, 사용량, 사용 가능 공간 및 사용률을 확인할 수 있어 디스크 용량 관리 시 유용합니다.
사용 예시: df -h
du -sh [경로]

설명: 특정 디렉토리 또는 파일의 디스크 사용량을 요약하여(summary) 사람이 읽기 쉬운 형식으로 보여줍니다. 어떤 디렉토리가 많은 공간을 차지하는지 파악할 때 유용합니다.
사용 예시: du -sh /var/log (로그 디렉토리 용량 확인)
free -h

설명: 시스템의 메모리(RAM) 사용량 및 스왑 공간 정보를 사람이 읽기 쉬운 형식으로 표시합니다. 사용 가능한 메모리, 사용 중인 메모리, 캐시/버퍼 메모리 등을 확인하여 시스템 성능 저하의 원인을 파악할 수 있습니다.
사용 예시: free -h
uptime

설명: 시스템이 부팅된 이후로 얼마나 오랫동안 실행되고 있는지, 현재 로그인한 사용자 수, 그리고 시스템의 평균 부하(load average)를 보여줍니다. 시스템의 안정성을 빠르게 확인할 수 있는 명령어입니다.
사용 예시: uptime
2. 파일 및 디렉토리 관리 명령어
리눅스에서 파일과 디렉토리를 생성, 삭제, 이동, 복사하고 권한을 변경하는 등 가장 빈번하게 사용되는 명령어들입니다.

ls -al

설명: 현재 디렉토리 또는 지정된 디렉토리의 모든 파일과 디렉토리 목록을 상세하게(long format) 보여줍니다. 파일 유형, 권한, 링크 수, 소유자, 그룹, 크기, 마지막 수정 시간 등을 포함하며, 숨김 파일(.)도 함께 표시합니다.
사용 예시: ls -al (현재 디렉토리), ls -al /home/user (특정 디렉토리)
cd [경로]

설명: 현재 작업 디렉토리를 변경합니다. .은 현재 디렉토리, ..은 상위 디렉토리를 의미합니다. 경로를 지정하지 않으면 사용자의 홈 디렉토리로 이동합니다.
사용 예시: cd /var/log, cd .., cd ~
pwd

설명: 현재 작업 디렉토리의 전체 경로를 출력합니다.
사용 예시: pwd
mkdir [디렉토리명]

설명: 새로운 디렉토리를 생성합니다. -p 옵션을 사용하면 상위 디렉토리가 없어도 함께 생성됩니다.
사용 예시: mkdir my_new_directory, mkdir -p project/src/main
rmdir [디렉토리명]

설명: 비어있는 디렉토리를 삭제합니다. 디렉토리가 비어있지 않으면 삭제할 수 없습니다. 비어있지 않은 디렉토리와 그 안의 파일들을 강제로 삭제하려면 rm -rf를 사용합니다.
사용 예시: rmdir empty_dir
cp [원본] [대상]

설명: 파일 또는 디렉토리를 복사합니다. 디렉토리를 복사하려면 -r (recursive) 옵션을 사용해야 합니다.
사용 예시: cp file.txt new_file.txt, cp -r my_dir /backup/
mv [원본] [대상]

설명: 파일 또는 디렉토리의 이름을 변경하거나 위치를 이동시킵니다.
사용 예시: mv old_name.txt new_name.txt, mv file.txt /another_directory/
rm [파일/디렉토리]

설명: 파일 또는 디렉토리를 삭제합니다. 디렉토리를 삭제하려면 -r (recursive) 옵션이 필요하며, -f (force) 옵션을 사용하면 확인 메시지 없이 강제로 삭제합니다. rm -rf는 매우 강력하고 위험한 명령어이므로 사용에 극히 주의해야 합니다.
사용 예시: rm myfile.txt, rm -rf my_directory
touch [파일명]

설명: 비어있는 새로운 파일을 생성하거나, 기존 파일의 마지막 수정 시간을 현재 시간으로 업데이트합니다.
사용 예시: touch new_empty_file.txt
cat [파일명]

설명: 파일의 내용을 터미널에 출력합니다. 여러 파일을 연결하여 출력하거나, 파이프라인을 통해 다른 명령어의 입력으로 사용할 수도 있습니다.
사용 예시: cat /etc/passwd, cat file1.txt file2.txt > combined.txt
less [파일명]

설명: 파일을 페이지 단위로 조회합니다. cat과 달리 파일 내용이 길어도 터미널 화면을 넘치지 않고, 위아래로 스크롤하며 내용을 탐색할 수 있습니다. q로 종료합니다.
사용 예시: less /var/log/syslog
head [파일명] / tail [파일명]

설명: head는 파일의 **시작 부분(기본 10줄)**을, tail은 파일의 **끝 부분(기본 10줄)**을 출력합니다. tail -f는 파일의 내용이 추가될 때 실시간으로 업데이트되는 로그 파일 모니터링에 매우 유용합니다.
사용 예시: head /etc/hosts, tail -f /var/log/nginx/access.log
3. 사용자 및 권한 관리 명령어
리눅스는 다중 사용자 시스템이므로, 사용자 계정을 생성하고 관리하며 파일 및 디렉토리의 접근 권한을 제어하는 것이 중요합니다.

sudo

설명: 루트(root) 사용자 또는 다른 사용자의 권한으로 명령어를 실행할 수 있게 해줍니다. 보안상의 이유로 직접 루트 계정으로 로그인하는 대신 sudo를 사용하여 필요한 경우에만 관리자 권한을 획득하는 것이 일반적입니다.
사용 예시: sudo apt update, sudo service apache2 restart
adduser [계정명] / userdel [계정명]

설명: 새로운 사용자 계정을 생성하거나(adduser) 삭제합니다(userdel). adduser는 홈 디렉토리 생성, 쉘 설정 등 기본적인 사용자 환경 설정을 자동으로 수행합니다. userdel -r은 사용자 홈 디렉토리까지 함께 삭제합니다.
사용 예시: sudo adduser newuser, sudo userdel -r olduser
passwd [계정명]

설명: 사용자 계정의 비밀번호를 변경합니다. [계정명]을 지정하지 않으면 현재 로그인한 사용자의 비밀번호를 변경합니다.
사용 예시: passwd, sudo passwd root
chown [소유자:그룹] [파일/디렉토리]

설명: 파일 또는 디렉토리의 소유자와 그룹을 변경합니다. 재귀적으로 변경하려면 -R 옵션을 사용합니다.
사용 예시: sudo chown user1:staff myfile.txt, sudo chown -R www-data:www-data /var/www/html
chmod [권한] [파일/디렉토리]

설명: 파일 또는 디렉토리의 접근 권한을 변경합니다. 숫자(예: 755) 또는 심볼릭(예: u+x, g-w) 모드를 사용하여 읽기(r), 쓰기(w), 실행(x) 권한을 설정합니다. 재귀적으로 변경하려면 -R 옵션을 사용합니다.
사용 예시: chmod 755 myscript.sh (소유자 rwx, 그룹 rx, 기타 rx), chmod u+x myfile
4. 프로세스 관리 명령어
시스템에서 실행 중인 프로세스를 확인하고 제어하는 명령어들입니다. 시스템 자원 모니터링 및 문제 발생 시 특정 프로세스를 종료하는 데 사용됩니다.

ps aux

설명: 현재 시스템에서 실행 중인 모든 프로세스의 상세 정보를 출력합니다. 사용자, CPU 사용률, 메모리 사용률, 시작 시간, 명령어 등 다양한 정보를 포함합니다. -a (모든 사용자), -u (사용자/그룹으로 표시), -x (제어 터미널이 없는 프로세스 포함) 옵션을 자주 함께 사용합니다.
사용 예시: ps aux | grep nginx (Nginx 프로세스만 필터링)
top

설명: 실시간으로 시스템의 프로세스 활동을 모니터링합니다. CPU, 메모리 사용률이 높은 프로세스를 상단에 표시하여 시스템 성능 문제를 즉시 파악할 수 있도록 돕습니다. 대화형 인터페이스로, q를 눌러 종료합니다.
사용 예시: top
htop

설명: top의 개선된 버전으로, 더 직관적인 인터페이스와 색상 강조, 그리고 마우스 클릭을 통한 프로세스 관리 기능을 제공합니다. 기본 시스템에는 포함되어 있지 않을 수 있으므로 설치가 필요합니다 (sudo apt install htop 등).
사용 예시: htop
kill [PID]

설명: 특정 프로세스를 종료합니다. [PID]는 ps 또는 top 명령어로 확인한 프로세스 ID(Process ID)입니다. 기본적으로 SIGTERM 시그널을 보내 프로세스가 정상적으로 종료되도록 유도합니다.
사용 예시: kill 12345
killall [프로세스명]

설명: 지정된 이름을 가진 모든 프로세스를 종료합니다. 동일한 이름의 여러 프로세스를 한 번에 종료할 때 편리합니다.
사용 예시: killall firefox
pkill [패턴]

설명: 프로세스 이름의 일부 패턴을 사용하여 프로세스를 종료합니다. killall보다 더 유연하게 프로세스를 선택하여 종료할 수 있습니다.
사용 예시: pkill -f "python my_script.py"
5. 압축 및 아카이브 명령어
파일과 디렉토리를 묶거나 압축하여 저장 공간을 효율적으로 사용하고 전송을 용이하게 합니다.

tar -cvf [아카이브명.tar] [대상] (묶기)

설명: 여러 파일이나 디렉토리를 하나의 아카이브 파일(*.tar)로 묶습니다. 압축은 하지 않습니다.
사용 예시: tar -cvf backup.tar /var/www/html
tar -xvf [아카이브명.tar] (풀기)

설명: tar 아카이브 파일의 압축을 해제합니다.
사용 예시: tar -xvf backup.tar
tar -czvf [아카이브명.tar.gz] [대상] (묶고 gzip 압축)

설명: 파일/디렉토리를 묶고 gzip으로 압축합니다. (-z 옵션 추가)
사용 예시: tar -czvf backup.tar.gz /var/www/html
tar -xzvf [아카이브명.tar.gz] (gzip 압축 풀기)

설명: tar.gz 파일의 압축을 해제합니다.
사용 예시: tar -xzvf backup.tar.gz
zip [아카이브명.zip] [대상]

설명: 파일이나 디렉토리를 .zip 형식으로 압축합니다. 디렉토리를 압축하려면 -r 옵션을 사용합니다.
사용 예시: zip -r my_files.zip my_directory/
unzip [아카이브명.zip]

설명: .zip 파일의 압축을 해제합니다.
사용 예시: unzip my_files.zip


5. grep: 텍스트 검색 및 필터링의 대가

grep (Global Regular Expression Print)은 파일 내용에서 특정 패턴(정규 표현식)을 검색하고, 해당 패턴을 포함하는 줄을 출력하는 강력한 도구입니다. 로그 분석, 설정 파일 검색, 코드 내 특정 문자열 찾기 등 활용 범위가 매우 넓습니다.

기본 사용법: grep [옵션] '패턴' [파일명]
설명: 지정된 파일에서 '패턴'과 일치하는 줄을 찾아 출력합니다. 패턴은 단순 문자열일 수도 있고, 정규 표현식일 수도 있습니다.
사용 예시:
grep 'error' /var/log/syslog: syslog 파일에서 "error" 문자열이 포함된 모든 줄을 출력합니다.
grep -i 'warning' app.log: app.log 파일에서 "warning"을 대소문자 구분 없이 검색합니다. (-i 옵션)
grep -n 'failed' auth.log: auth.log 파일에서 "failed"를 검색하고, 일치하는 줄의 줄 번호를 함께 출력합니다. (-n 옵션)
grep -r 'config' /etc/: /etc 디렉토리와 그 하위 디렉토리의 모든 파일에서 "config"를 재귀적으로 검색합니다. (-r 옵션)
grep -v 'info' debug.log: debug.log 파일에서 "info" 문자열이 포함되지 않은 줄만 출력합니다. (-v 옵션, 패턴 제외)
ps aux | grep 'apache2': ps aux의 결과(실행 중인 모든 프로세스)를 파이프로 grep에 전달하여 "apache2" 문자열이 포함된 프로세스만 필터링합니다.

6. find: 파일 및 디렉토리 검색의 전문가


find는 파일 시스템 내에서 특정 조건에 맞는 파일이나 디렉토리를 검색하는 데 사용됩니다. 이름, 크기, 수정 시간, 소유자, 권한 등 다양한 기준으로 검색할 수 있으며, 검색된 파일에 대해 특정 작업을 수행할 수도 있습니다.

기본 사용법: find [경로] [옵션] [조건]
설명: 지정된 경로에서 조건에 맞는 파일이나 디렉토리를 찾아 출력합니다.
사용 예시:
find . -name '*.log': 현재 디렉토리 및 하위 디렉토리에서 확장자가 .log인 모든 파일을 찾습니다.
find /var/www -type d -name 'cache': /var/www 아래에서 이름이 "cache"인 디렉토리만 찾습니다. (-type d는 디렉토리, -type f는 파일)
find /tmp -size +1G: /tmp 디렉토리에서 크기가 1GB보다 큰 파일을 찾습니다. (+는 보다 큼, -는 보다 작음)
find /home/user -mtime +7: /home/user에서 마지막 수정된 지 7일이 넘은 파일을 찾습니다. (+7은 7일 전보다 오래됨, -7은 7일 이내)
find . -name '*.bak' -delete: 현재 디렉토리에서 .bak 확장자를 가진 모든 파일을 찾아서 바로 삭제합니다. (-delete 옵션은 주의해서 사용)
find /var/log -type f -exec gzip {} \;: /var/log 디렉토리의 모든 파일을 찾아서 gzip으로 압축합니다. (-exec 옵션은 찾은 파일에 대해 명령을 실행)


7. sed: 스트림 에디터로 텍스트 변환
sed (Stream EDitor)는 텍스트 스트림을 편집하는 데 사용되는 비대화형(non-interactive) 명령어입니다. 파일 내용을 직접 수정하기보다는, 입력된 텍스트에 대해 지정된 규칙에 따라 변경 사항을 적용한 후 결과를 출력하는 방식입니다. 특정 문자열 치환, 줄 삭제, 삽입 등 다양한 텍스트 조작이 가능합니다.

기본 사용법: sed [옵션] '스크립트' [파일명]
설명: 파일의 각 줄에 대해 '스크립트'에 명시된 편집 작업을 수행하고, 그 결과를 표준 출력으로 내보냅니다. 원본 파일은 변경되지 않습니다. 원본 파일을 직접 수정하려면 -i (in-place) 옵션을 사용해야 합니다.
사용 예시:
sed 's/old_string/new_string/g' file.txt: file.txt 파일에서 "old_string"을 "new_string"으로 모두(global) 치환하여 출력합니다.
sed '1d' file.txt: file.txt 파일의 첫 번째 줄을 삭제하고 출력합니다. (d는 delete)
sed '/^#/d' config.conf: config.conf 파일에서 #으로 시작하는 모든 주석 줄을 삭제하고 출력합니다.
sed -i 's/localhost/127.0.0.1/g' /etc/hosts: /etc/hosts 파일 내의 "localhost"를 "127.0.0.1"로 직접 변경합니다. (-i는 원본 파일 수정)
ls -l | sed 's/ */ /g': ls -l 출력의 여러 공백을 단일 공백으로 치환하여 가독성을 높입니다.


8. awk: 패턴 기반 텍스트 처리의 강력함
awk는 패턴 스캔 및 처리 언어로, 주로 복잡한 텍스트 데이터의 컬럼(필드) 기반 처리에 특화되어 있습니다. 데이터를 행과 열로 나누어 특정 조건을 만족하는 행을 선택하거나, 각 필드에 대해 수학적 연산이나 문자열 조작을 수행하는 데 탁월합니다. 보고서 생성이나 데이터 추출에 많이 활용됩니다.

기본 사용법: awk '[패턴] {액션}' [파일명]
설명: 파일의 각 줄을 읽어 [패턴]과 일치하면 {액션}을 수행합니다. 패턴이 없으면 모든 줄에 대해 액션을 수행합니다. 기본적으로 공백을 필드 구분자로 사용하여 $1, $2, ...와 같이 각 필드에 접근할 수 있습니다.
사용 예시:
awk '{print $1, $3}' access.log: access.log 파일에서 각 줄의 첫 번째와 세 번째 필드만 출력합니다.
awk '/ERROR/ {print $0}' error.log: error.log 파일에서 "ERROR" 문자열이 포함된 모든 줄($0는 전체 줄)을 출력합니다.
df -h | awk 'NR > 1 {print $1, $5}': df -h 결과에서 첫 번째 줄(헤더)을 제외하고, 첫 번째 필드(파일 시스템)와 다섯 번째 필드(사용률)만 출력합니다. (NR > 1은 줄 번호가 1보다 큰 경우)
cat data.txt | awk '{sum += $2} END {print "Total:", sum}': data.txt 파일의 두 번째 필드 값을 모두 더하여 최종 합계를 출력합니다. (END는 모든 줄 처리 후 실행)
awk -F':' '{print $1, $NF}' /etc/passwd: /etc/passwd 파일에서 콜론(:)을 필드 구분자로 사용하여 첫 번째 필드(사용자명)와 마지막 필드(쉘)를 출력합니다. (-F는 필드 구분자 지정, $NF는 마지막 필드)